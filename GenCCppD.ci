// GenCCppD.ci - base for C/C++/D code generators
//
// Copyright (C) 2011-2023  Piotr Fusik
//
// This file is part of CiTo, see https://github.com/pfusik/cito
//
// CiTo is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiTo is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiTo.  If not, see http://www.gnu.org/licenses/

public abstract class GenCCppD : GenTyped
{
	protected List<CiSwitch>() SwitchesWithGoto;

	static bool IsPtrTo(CiExpr ptr, CiExpr other) => ptr.Type is CiClassType klass && klass.Class.Id != CiId.StringClass && klass.IsAssignableFrom(other.Type);

	protected override void WriteEqual!(CiExpr left, CiExpr right, CiPriority parent, bool not)
	{
		CiType coercedType;
		if (IsPtrTo(left, right))
			coercedType = left.Type;
		else if (IsPtrTo(right, left))
			coercedType = right.Type;
		else {
			base.WriteEqual(left, right, parent, not);
			return;
		}
		if (parent > CiPriority.Equality)
			WriteChar('(');
		WriteCoerced(coercedType, left, CiPriority.Equality);
		Write(GetEqOp(not));
		WriteCoerced(coercedType, right, CiPriority.Equality);
		if (parent > CiPriority.Equality)
			WriteChar(')');
	}

	public override void VisitConst!(CiConst statement)
	{
		if (statement.Type is CiArrayStorageType)
			WriteConst(statement);
	}

	public override void VisitBreak!(CiBreak statement)
	{
		if (statement.LoopOrSwitch is CiSwitch switchStatement) {
			int gotoId = this.SwitchesWithGoto.IndexOf(switchStatement);
			if (gotoId >= 0) {
				Write("goto ciafterswitch");
				VisitLiteralLong(gotoId);
				WriteCharLine(';');
				return;
			}
		}
		base.VisitBreak(statement);
	}

	protected virtual void WriteSwitchCaseCond!(CiSwitch statement, CiExpr value, CiPriority parent)
	{
		if (value is CiBinaryExpr when1 && when1.Op == CiToken.When) {
			if (parent > CiPriority.SelectCond)
				WriteChar('(');
			WriteSwitchCaseCond(statement, when1.Left, CiPriority.CondAnd); // FIXME: side effect in every if
			Write(" && ");
			when1.Right.Accept(this, CiPriority.CondAnd);
			if (parent > CiPriority.SelectCond)
				WriteChar(')');
		}
		else
			WriteEqual(statement.Value, value, parent, false); // FIXME: side effect in every if
	}

	void WriteIfCaseBody!(List<CiStatement#> body, bool doWhile)
	{
		int length = CiSwitch.LengthWithoutTrailingBreak(body);
		if (doWhile && CiSwitch.HasEarlyBreak(body)) {
			this.Indent++;
			WriteNewLine();
			Write("do ");
			OpenBlock();
			WriteFirstStatements(body, length);
			CloseBlock();
			WriteLine("while (0);");
			this.Indent--;
		}
		else if (length != 1 || body[0] is CiIf) {
			WriteChar(' ');
			OpenBlock();
			WriteFirstStatements(body, length);
			CloseBlock();
		}
		else
			WriteChild(body[0]);
	}

	protected void WriteSwitchAsIfs!(CiSwitch statement)
	{
		int gotoId;
		if (statement.Cases.Any(kase => CiSwitch.HasEarlyBreakAndContinue(kase.Body))
		 || CiSwitch.HasEarlyBreakAndContinue(statement.DefaultBody)) {
			gotoId = this.SwitchesWithGoto.Count;
			this.SwitchesWithGoto.Add(statement);
		}
		else
			gotoId = -1;
		string op = "if (";
		foreach (CiCase kase in statement.Cases) {
			CiPriority parent = kase.Values.Count == 1 ? CiPriority.Argument : CiPriority.CondOr;
			foreach (CiExpr value in kase.Values) {
				Write(op);
				WriteSwitchCaseCond(statement, value, parent);
				op = " || ";
			}
			WriteChar(')');
			WriteIfCaseBody(kase.Body, gotoId < 0);
			op = "else if (";
		}
		if (statement.HasDefault()) {
			Write("else");
			WriteIfCaseBody(statement.DefaultBody, gotoId < 0);
		}
		if (gotoId >= 0) {
			Write("ciafterswitch");
			VisitLiteralLong(gotoId);
			WriteLine(": ;");
		}
	}
}
