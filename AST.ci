// AST.ci - Ci abstract syntax tree
//
// Copyright (C) 2011-2023  Piotr Fusik
//
// This file is part of CiTo, see https://github.com/pfusik/cito
//
// CiTo is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiTo is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiTo.  If not, see http://www.gnu.org/licenses/

public enum CiVisibility
{
	Private,
	Internal,
	Protected,
	Public,
	NumericElementType,
	FinalValueType
}

public enum CiCallType
{
	Static,
	Normal,
	Abstract,
	Virtual,
	Override,
	Sealed
}

public enum CiPriority
{
	Statement,
	Argument,
	Assign,
	Select,
	SelectCond,
	CondOr,
	CondAnd,
	Or,
	Xor,
	And,
	Equality,
	Rel,
	Shift,
	Add,
	Mul,
	Primary
}

public enum CiId
{
	None,
	VoidType,
	NullType,
	BasePtr,
	TypeParam0,
	TypeParam0NotFinal,
	TypeParam0Predicate,
	SByteRange,
	ByteRange,
	ShortRange,
	UShortRange,
	IntType,
	LongType,
	FloatType,
	DoubleType,
	FloatIntType,
	BoolType,
	StringClass,
	StringPtrType,
	StringStorageType,
	ArrayPtrClass,
	ArrayStorageClass,
	ListClass,
	QueueClass,
	StackClass,
	HashSetClass,
	SortedSetClass,
	DictionaryClass,
	SortedDictionaryClass,
	OrderedDictionaryClass,
	TextWriterClass,
	StringWriterClass,
	RegexOptionsEnum,
	RegexClass,
	MatchClass,
	LockClass,
	StringLength,
	ArrayLength,
	ConsoleError,
	ClassToString,
	MatchStart,
	MatchEnd,
	MatchLength,
	MatchValue,
	MathNaN,
	MathNegativeInfinity,
	MathPositiveInfinity,
	EnumHasFlag,
	IntTryParse,
	LongTryParse,
	DoubleTryParse,
	StringContains,
	StringEndsWith,
	StringIndexOf,
	StringLastIndexOf,
	StringReplace,
	StringStartsWith,
	StringSubstring,
	ArrayBinarySearchAll,
	ArrayBinarySearchPart,
	ArrayCopyTo,
	ArrayFillAll,
	ArrayFillPart,
	ArraySortAll,
	ArraySortPart,
	ListAdd,
	ListAddRange,
	ListAll,
	ListAny,
	ListClear,
	ListContains,
	ListCopyTo,
	ListCount,
	ListIndexOf,
	ListInsert,
	ListLast,
	ListRemoveAt,
	ListRemoveRange,
	ListSortAll,
	ListSortPart,
	QueueClear,
	QueueCount,
	QueueDequeue,
	QueueEnqueue,
	QueuePeek,
	StackClear,
	StackCount,
	StackPeek,
	StackPush,
	StackPop,
	HashSetAdd,
	HashSetClear,
	HashSetContains,
	HashSetCount,
	HashSetRemove,
	SortedSetAdd,
	SortedSetClear,
	SortedSetContains,
	SortedSetCount,
	SortedSetRemove,
	DictionaryAdd,
	DictionaryClear,
	DictionaryContainsKey,
	DictionaryCount,
	DictionaryRemove,
	SortedDictionaryClear,
	SortedDictionaryContainsKey,
	SortedDictionaryCount,
	SortedDictionaryRemove,
	OrderedDictionaryClear,
	OrderedDictionaryContainsKey,
	OrderedDictionaryCount,
	OrderedDictionaryRemove,
	TextWriterWrite,
	TextWriterWriteChar,
	TextWriterWriteLine,
	ConsoleWrite,
	ConsoleWriteLine,
	StringWriterClear,
	StringWriterToString,
	UTF8GetByteCount,
	UTF8GetBytes,
	UTF8GetString,
	EnvironmentGetEnvironmentVariable,
	RegexCompile,
	RegexEscape,
	RegexIsMatchStr,
	RegexIsMatchRegex,
	MatchFindStr,
	MatchFindRegex,
	MatchGetCapture,
	MathMethod,
	MathAbs,
	MathCeiling,
	MathClamp,
	MathFusedMultiplyAdd,
	MathIsFinite,
	MathIsInfinity,
	MathIsNaN,
	MathLog2,
	MathMaxInt,
	MathMaxDouble,
	MathMinInt,
	MathMinDouble,
	MathRound,
	MathTruncate
}

abstract class CiDocInline
{
}

class CiDocText : CiDocInline
{
	internal string() Text;
}

class CiDocCode : CiDocInline
{
	internal string() Text;
}

class CiDocLine : CiDocInline
{
}

public abstract class CiDocBlock
{
}

public class CiDocPara : CiDocBlock
{
	internal List<CiDocInline#>() Children;
}

public class CiDocList : CiDocBlock
{
	internal List<CiDocPara()>() Items;
}

public class CiCodeDoc
{
	internal CiDocPara() Summary;
	internal List<CiDocBlock#>() Details;
}

public abstract class CiVisitor
{
	internal bool HasErrors = false;
	protected abstract CiContainerType GetCurrentContainer();
	protected void VisitOptionalStatement!(CiStatement? statement)
	{
		if (statement != null)
			statement.AcceptStatement(this);
	}
	protected void ReportError!(CiStatement statement, string message)
	{
		Console.Error.WriteLine($"{GetCurrentContainer().Filename}({statement.Line}): ERROR: {message}");
		this.HasErrors = true;
	}

	public abstract void VisitConst!(CiConst statement);
	public abstract void VisitExpr!(CiExpr statement);
	public abstract void VisitBlock!(CiBlock statement);
	public abstract void VisitAssert!(CiAssert statement);
	public abstract void VisitBreak!(CiBreak statement);
	public abstract void VisitContinue!(CiContinue statement);
	public abstract void VisitDoWhile!(CiDoWhile statement);
	public abstract void VisitFor!(CiFor statement);
	public abstract void VisitForeach!(CiForeach statement);
	public abstract void VisitIf!(CiIf statement);
	public abstract void VisitLock!(CiLock statement);
	public abstract void VisitNative!(CiNative statement);
	public abstract void VisitReturn!(CiReturn statement);
	public abstract void VisitSwitch!(CiSwitch statement);
	public abstract void VisitThrow!(CiThrow statement);
	public abstract void VisitWhile!(CiWhile statement);
	public abstract void VisitEnumValue!(CiConst konst, CiConst? previous);
	public abstract void VisitLiteralNull!();
	public abstract void VisitLiteralFalse!();
	public abstract void VisitLiteralTrue!();
	public abstract void VisitLiteralLong!(long value);
	public abstract void VisitLiteralChar!(int value);
	public abstract void VisitLiteralDouble!(double value);
	public abstract void VisitLiteralString!(string value);
	public abstract void VisitAggregateInitializer!(CiAggregateInitializer expr);
	public abstract void VisitInterpolatedString!(CiInterpolatedString expr, CiPriority parent);
	public abstract void VisitSymbolReference!(CiSymbolReference expr, CiPriority parent);
	public abstract void VisitPrefixExpr!(CiPrefixExpr expr, CiPriority parent);
	public abstract void VisitPostfixExpr!(CiPostfixExpr expr, CiPriority parent);
	public abstract void VisitBinaryExpr!(CiBinaryExpr expr, CiPriority parent);
	public abstract void VisitSelectExpr!(CiSelectExpr expr, CiPriority parent);
	public abstract void VisitCallExpr!(CiCallExpr expr, CiPriority parent);
	public abstract void VisitLambdaExpr!(CiLambdaExpr expr);
	public abstract void VisitVar!(CiVar expr);
}

public abstract class CiStatement
{
	internal int Line;
	public abstract bool CompletesNormally();
	public abstract void AcceptStatement(CiVisitor! visitor);
}

public abstract class CiExpr : CiStatement
{
	internal CiType#? Type;
	public override bool CompletesNormally() => true;
	public virtual string() ToString() { assert false; }
	public virtual bool IsIndexing() => false;
	public virtual bool IsLiteralZero() => false;
	public virtual bool IsConstEnum() => false;
	public virtual int IntValue() { assert false; }
	public virtual void Accept(CiVisitor! visitor, CiPriority parent) { assert false; }
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitExpr(this); }
	public virtual bool IsReferenceTo(CiSymbol symbol) => false;
}

public abstract class CiSymbol : CiExpr
{
	internal CiId Id = CiId.None;
	internal string() Name;
	internal CiSymbol!? Next;
	internal CiScope!? Parent;
	internal CiCodeDoc#? Documentation = null;
	public override string() ToString() => this.Name;
}

public class CiScope : CiSymbol
{
	protected Dictionary<string, CiSymbol#>() Dict;
	internal CiSymbol!? First = null;
	CiSymbol!? Last;

	public int Count() => this.Dict.Count;

	public CiVar!? FirstParameter()
	{
		assert this.First is CiVar! result; // FIXME: CiVar!?
		return result;
	}

	public CiContainerType! GetContainer!()
	{
		for (CiScope!? scope = this; scope != null; scope = scope.Parent) {
			if (scope is CiContainerType! container)
				return container;
		}
		assert false;
	}

	public bool Contains(CiSymbol symbol) => this.Dict.ContainsKey(symbol.Name);

	public CiSymbol#? TryLookup(string name, bool global)
	{
		for (CiScope? scope = this; scope != null && (global || !(scope is CiProgram || scope is CiSystem)); scope = scope.Parent) {
			if (scope.Dict.ContainsKey(name))
				return scope.Dict[name];
		}
		return null;
	}

	public void Add!(CiSymbol# symbol)
	{
		this.Dict[symbol.Name] = symbol;
		symbol.Next = null;
		symbol.Parent = this;
		if (this.First == null)
			this.First = symbol;
		else
			this.Last.Next = symbol;
		this.Last = symbol;
	}

	public bool Encloses(CiSymbol symbol)
	{
		for (CiScope? scope = symbol.Parent; scope != null; scope = scope.Parent) {
			if (scope == this)
				return true;
		}
		return false;
	}
}

public class CiAggregateInitializer : CiExpr
{
	internal List<CiExpr#>() Items;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitAggregateInitializer(this); }
}

public abstract class CiLiteral : CiExpr
{
	public abstract bool IsDefaultValue();
	public virtual string() GetLiteralString() { assert false; }
}

public class CiLiteralNull : CiLiteral
{
	public override bool IsDefaultValue() => true;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralNull(); }
	public override string() ToString() => "null";
}

public class CiLiteralFalse : CiLiteral
{
	public override bool IsDefaultValue() => true;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralFalse(); }
	public override string() ToString() => "false";
}

public class CiLiteralTrue : CiLiteral
{
	public override bool IsDefaultValue() => false;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralTrue(); }
	public override string() ToString() => "true";
}

public class CiLiteralLong : CiLiteral
{
	internal long Value;
	public override bool IsLiteralZero() => this.Value == 0;
	public override int IntValue() => this.Value;
	public override bool IsDefaultValue() => this.Value == 0;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralLong(this.Value); }
	public override string() GetLiteralString() => $"{this.Value}";
	public override string() ToString() => $"{this.Value}";
}

public class CiLiteralChar : CiLiteralLong
{
	public static CiLiteralChar# New(int value, int line) => new CiLiteralChar { Line = line, Type = CiRangeType.New(value, value), Value = value };
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralChar(this.Value); }
//	public override string() ToString()
//	{
//		switch (this.Value) {
//		case '\n': return "'\\n'";
//		case '\r': return "'\\r'";
//		case '\t': return "'\\t'";
//		case '\\': return "'\\\\'";
//		case '\'': return "'\\''";
//		default: return $"'{(char) this.Value}'";
//		}
//	}
}

public class CiLiteralDouble : CiLiteral
{
	internal double Value;
	public override bool IsDefaultValue() => this.Value == 0 && 1.0 / this.Value > 0; // rule out -0.0
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralDouble(this.Value); }
	public override string() GetLiteralString() => $"{this.Value}";
	public override string() ToString() => $"{this.Value}";
}

public class CiLiteralString : CiLiteral
{
	internal string() Value;
	public override bool IsDefaultValue() => false;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLiteralString(this.Value); }
	public override string() GetLiteralString() => this.Value;
	public override string() ToString() => $"\"{this.Value}\"";
	public int GetAsciiLength()
	{
		int length = 0;
		bool escaped = false;
		foreach (int c in this.Value) {
			if (c < 0 || c > 127)
				return -1;
			if (!escaped && c == '\\')
				escaped = true;
			else {
				length++;
				escaped = false;
			}
		}
		return length;
	}
	public int GetAsciiAt(int i)
	{
		bool escaped = false;
		foreach (int c in this.Value) {
			if (c < 0 || c > 127)
				return -1;
			if (!escaped && c == '\\')
				escaped = true;
			else if (i == 0)
				return escaped ? CiLexer.GetEscapedChar(c) : c;
			else {
				i--;
				escaped = false;
			}
		}
		return -1;
	}
	public int GetOneAscii()
	{
		switch (this.Value.Length) {
		case 1:
			int c = this.Value[0];
			return c >= 0 && c <= 127 ? c : -1;
		case 2:
			return this.Value[0] == '\\' ? CiLexer.GetEscapedChar(this.Value[1]) : -1;
		default:
			return -1;
		}
	}
}

public class CiInterpolatedPart
{
	internal string() Prefix;
	internal CiExpr# Argument;
	internal CiExpr#? WidthExpr;
	internal int Width;
	internal int Format;
	internal int Precision;
}

public class CiInterpolatedString : CiExpr
{
	internal List<CiInterpolatedPart()>() Parts;
	internal string() Suffix;
	public void AddPart!(string prefix, CiExpr# arg, CiExpr#? widthExpr = null, int format = ' ', int precision = -1)
	{
		this.Parts.Add();
		CiInterpolatedPart! part = this.Parts.Last();
		part.Prefix = prefix;
		part.Argument = arg;
		part.WidthExpr = widthExpr;
		part.Format = format;
		part.Precision = precision;
	}
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitInterpolatedString(this, parent); }
//	public override string() ToString()
//	{
//		StringBuilder sb = new StringBuilder();
//		sb.Append("$\"");
//		foreach (CiInterpolatedPart part in this.Parts) {
//			sb.Append(part.Prefix.Replace("{", "{{"));
//			sb.Append('{');
//			sb.Append(part.Argument);
//			if (part.WidthExpr != null) {
//				sb.Append(',');
//				sb.Append(part.WidthExpr);
//			}
//			if (part.Format != ' ') {
//				sb.Append(':');
//				sb.Append((char) part.Format);
//				if (part.Precision >= 0)
//					sb.Append(part.Precision);
//			}
//			sb.Append('}');
//		}
//		sb.Append(this.Suffix.Replace("{", "{{"));
//		sb.Append('"');
//		return sb.ToString();
//	}
}

public class CiImplicitEnumValue : CiExpr
{
	internal int Value;
	public override int IntValue() => this.Value;
}

public class CiSymbolReference : CiExpr
{
	internal CiExpr#? Left;
	internal string() Name;
	internal CiSymbol!? Symbol;
	public override bool IsConstEnum() => this.Symbol.Parent is CiEnum;
	public override int IntValue()
	{
		assert this.Symbol is CiConst konst;
		return konst.Value.IntValue();
	}
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitSymbolReference(this, parent); }
	public override bool IsReferenceTo(CiSymbol symbol) => this.Symbol == symbol;
	public override string() ToString() => this.Left != null ? $"{this.Left}.{this.Name}" : this.Name;
}

public abstract class CiUnaryExpr : CiExpr
{
	internal CiToken Op;
	internal CiExpr#? Inner;
}

public class CiPrefixExpr : CiUnaryExpr
{
	public override bool IsConstEnum() => this.Type is CiEnumFlags && this.Inner.IsConstEnum(); // && this.Op == CiToken.Tilde
	public override int IntValue()
	{
		assert this.Op == CiToken.Tilde;
		return ~this.Inner.IntValue();
	}
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitPrefixExpr(this, parent); }
}

public class CiPostfixExpr : CiUnaryExpr
{
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitPostfixExpr(this, parent); }
}

public class CiBinaryExpr : CiExpr
{
	internal CiExpr# Left;
	internal CiToken Op;
	internal CiExpr#? Right;
	public override bool IsIndexing() => this.Op == CiToken.LeftBracket;
	public override bool IsConstEnum()
	{
		switch (this.Op) {
		case CiToken.And:
		case CiToken.Or:
		case CiToken.Xor:
			return this.Type is CiEnumFlags && this.Left.IsConstEnum() && this.Right.IsConstEnum();
		default:
			return false;
		}
	}
	public override int IntValue()
	{
		switch (this.Op) {
		case CiToken.And:
			return this.Left.IntValue() & this.Right.IntValue();
		case CiToken.Or:
			return this.Left.IntValue() | this.Right.IntValue();
		case CiToken.Xor:
			return this.Left.IntValue() ^ this.Right.IntValue();
		default:
			assert false;
		}
	}
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitBinaryExpr(this, parent); }
	public bool IsAssign()
	{
		switch (this.Op) {
		case CiToken.Assign:
		case CiToken.AddAssign:
		case CiToken.SubAssign:
		case CiToken.MulAssign:
		case CiToken.DivAssign:
		case CiToken.ModAssign:
		case CiToken.ShiftLeftAssign:
		case CiToken.ShiftRightAssign:
		case CiToken.AndAssign:
		case CiToken.OrAssign:
		case CiToken.XorAssign:
			return true;
		default:
			return false;
		}
	}

	public string GetOpString()
	{
		switch (this.Op) {
		case CiToken.Plus:
			return "+";
		case CiToken.Minus:
			return "-";
		case CiToken.Asterisk:
			return "*";
		case CiToken.Slash:
			return "/";
		case CiToken.Mod:
			return "%";
		case CiToken.ShiftLeft:
			return "<<";
		case CiToken.ShiftRight:
			return ">>";
		case CiToken.Less:
			return "<";
		case CiToken.LessOrEqual:
			return "<=";
		case CiToken.Greater:
			return ">";
		case CiToken.GreaterOrEqual:
			return ">=";
		case CiToken.Equal:
			return "==";
		case CiToken.NotEqual:
			return "!=";
		case CiToken.And:
			return "&";
		case CiToken.Or:
			return "|";
		case CiToken.Xor:
			return "^";
		case CiToken.CondAnd:
			return "&&";
		case CiToken.CondOr:
			return "||";
		case CiToken.Assign:
			return "=";
		case CiToken.AddAssign:
			return "+=";
		case CiToken.SubAssign:
			return "-=";
		case CiToken.MulAssign:
			return "*=";
		case CiToken.DivAssign:
			return "/=";
		case CiToken.ModAssign:
			return "%=";
		case CiToken.ShiftLeftAssign:
			return "<<=";
		case CiToken.ShiftRightAssign:
			return ">>=";
		case CiToken.AndAssign:
			return "&=";
		case CiToken.OrAssign:
			return "|=";
		case CiToken.XorAssign:
			return "^=";
		default:
			assert false;
		}
	}

	public override string() ToString() => this.Op == CiToken.LeftBracket ? $"{this.Left}[{this.Right}]" : $"({this.Left} {GetOpString()} {this.Right})";
}

public class CiSelectExpr : CiExpr
{
	internal CiExpr# Cond;
	internal CiExpr# OnTrue;
	internal CiExpr# OnFalse;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitSelectExpr(this, parent); }
	public override string() ToString() => $"({this.Cond} ? {this.OnTrue} : {this.OnFalse})";
}

public class CiCallExpr : CiExpr
{
	internal CiSymbolReference# Method;
	internal List<CiExpr#>() Arguments;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitCallExpr(this, parent); }
}

public class CiLambdaExpr : CiScope
{
	internal CiExpr# Body;
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitLambdaExpr(this); }
}

public abstract class CiCondCompletionStatement : CiScope
{
	bool CompletesNormallyValue;
	public override bool CompletesNormally() => this.CompletesNormallyValue;
	public void SetCompletesNormally!(bool value) { this.CompletesNormallyValue = value; }
}

public class CiBlock : CiCondCompletionStatement
{
	internal List<CiStatement#>() Statements;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitBlock(this); }
}

public class CiAssert : CiStatement
{
	internal CiExpr# Cond;
	internal CiExpr#? Message = null;
	public override bool CompletesNormally() => !(this.Cond is CiLiteralFalse);
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitAssert(this); }
}

public abstract class CiLoop : CiCondCompletionStatement
{
	internal CiExpr#? Cond;
	internal CiStatement# Body;
	internal bool HasBreak = false;
}

public class CiBreak : CiStatement
{
	internal CiCondCompletionStatement! LoopOrSwitch;
	public override bool CompletesNormally() => false;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitBreak(this); }
}

public class CiContinue : CiStatement
{
	internal CiLoop Loop;
	public override bool CompletesNormally() => false;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitContinue(this); }
}

public class CiDoWhile : CiLoop
{
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitDoWhile(this); }
}

public class CiFor : CiLoop
{
	internal CiExpr#? Init;
	internal CiExpr#? Advance;
	internal bool IsRange = false;
	internal bool IsIteratorUsed;
	internal long RangeStep;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitFor(this); }
}

public class CiForeach : CiLoop
{
	internal CiExpr# Collection;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitForeach(this); }
	public CiVar! GetVar() => this.FirstParameter();
	public CiVar! GetValueVar() => this.FirstParameter().NextParameter();
}

public class CiIf : CiCondCompletionStatement
{
	internal CiExpr# Cond;
	internal CiStatement# OnTrue;
	internal CiStatement#? OnFalse;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitIf(this); }
}

public class CiLock : CiStatement
{
	internal CiExpr# Lock;
	internal CiStatement# Body;
	public override bool CompletesNormally() => this.Body.CompletesNormally();
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitLock(this); }
}

public class CiNative : CiStatement
{
	internal string() Content;
	public override bool CompletesNormally() => true;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitNative(this); }
}

public class CiReturn : CiStatement
{
	internal CiExpr#? Value;
	public override bool CompletesNormally() => false;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitReturn(this); }
}

public class CiCase
{
	internal List<CiExpr#>() Values;
	internal List<CiStatement#>() Body;
}

public class CiSwitch : CiCondCompletionStatement
{
	internal CiExpr# Value;
	internal List<CiCase()>() Cases;
	internal List<CiStatement#>() DefaultBody;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitSwitch(this); }

	public bool IsTypeMatching() => this.Value.Type is CiClassType klass && klass.Class.Id != CiId.StringClass;

	public bool HasWhen() => this.Cases.Any(kase => kase.Values.Any(value => value is CiBinaryExpr when1 && when1.Op == CiToken.When));

	public static int LengthWithoutTrailingBreak(List<CiStatement#> body)
	{
		int length = body.Count;
		if (length > 0 && body[length - 1] is CiBreak)
			length--;
		return length;
	}

	public bool HasDefault() => LengthWithoutTrailingBreak(this.DefaultBody) > 0;

	static bool HasBreak(CiStatement statement)
	{
		switch (statement) {
		case CiBreak _:
			return true;
		case CiIf ifStatement:
			return HasBreak(ifStatement.OnTrue) || (ifStatement.OnFalse != null && HasBreak(ifStatement.OnFalse));
		case CiBlock block:
			return block.Statements.Any(child => HasBreak(child));
		default:
			return false;
		}
	}

	public static bool HasEarlyBreak(List<CiStatement#> body)
	{
		int length = LengthWithoutTrailingBreak(body);
		for (int i = 0; i < length; i++) {
			if (HasBreak(body[i]))
				return true;
		}
		return false;
	}

	static bool ListHasContinue(List<CiStatement#> statements) => statements.Any(statement => HasContinue(statement));

	static bool HasContinue(CiStatement statement)
	{
		switch (statement) {
		case CiContinue _:
			return true;
		case CiIf ifStatement:
			return HasContinue(ifStatement.OnTrue) || (ifStatement.OnFalse != null && HasContinue(ifStatement.OnFalse));
		case CiSwitch switchStatement:
			return switchStatement.Cases.Any(kase => ListHasContinue(kase.Body)) || ListHasContinue(switchStatement.DefaultBody);
		case CiBlock block:
			return ListHasContinue(block.Statements);
		default:
			return false;
		}
	}

	public static bool HasEarlyBreakAndContinue(List<CiStatement#> body) => HasEarlyBreak(body) && ListHasContinue(body);
}

public class CiThrow : CiStatement
{
	internal CiExpr# Message;
	public override bool CompletesNormally() => false;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitThrow(this); }
}

public class CiWhile : CiLoop
{
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitWhile(this); }
}

public class CiParameters : CiScope
{
}

public class CiType : CiScope
{
	internal bool Nullable = false;
	public virtual string() GetArraySuffix() => "";
	public virtual bool IsAssignableFrom(CiType right) => this == right;
	public virtual bool EqualsType(CiType right) => this == right;
	public virtual bool IsArray() => false;
	public virtual bool IsFinal() => false;
	public virtual CiType GetBaseType() => this;
	public virtual CiType GetStorageType() => this;
	public CiClassType AsClassType()
	{
		assert this is CiClassType klass;
		return klass;
	}
}

public abstract class CiNumericType : CiType
{
}

public class CiIntegerType : CiNumericType
{
	public override bool IsAssignableFrom(CiType right) => right is CiIntegerType || right.Id == CiId.FloatIntType;
}

public class CiRangeType : CiIntegerType
{
	internal int Min;
	internal int Max;

	static void AddMinMaxValue(CiRangeType# target, string name, int value)
	{
		CiRangeType# type = target.Min == target.Max ? target : new CiRangeType { Min = value, Max = value };
		target.Add(new CiConst { Visibility = CiVisibility.Public, Name = name, Value = new CiLiteralLong { Type = type, Value = value }, VisitStatus = CiVisitStatus.Done });
	}

	public static CiRangeType# New(int min, int max)
	{
		assert min <= max;
		CiRangeType# result = new CiRangeType { Id =
			min >= 0 && max <= byte.MaxValue ? CiId.ByteRange :
 			min >= -128 && max <= 127 ? CiId.SByteRange :
			min >= short.MinValue && max <= short.MaxValue ? CiId.ShortRange :
			min >= 0 && max <= ushort.MaxValue ? CiId.UShortRange :
			CiId.IntType, Min = min, Max = max };
		AddMinMaxValue(result, "MinValue", min);
		AddMinMaxValue(result, "MaxValue", max);
		return result;
	}

	public override string() ToString() => this.Min == this.Max ? $"{this.Min}" : $"({this.Min} .. {this.Max})";

	public override bool IsAssignableFrom(CiType right)
	{
		switch (right) {
		case CiRangeType range:
			return this.Min <= range.Max && this.Max >= range.Min;
		case CiIntegerType _:
			return true;
		default:
			return right.Id == CiId.FloatIntType;
		}
	}

	public override bool EqualsType(CiType right) => right is CiRangeType that && this.Min == that.Min && this.Max == that.Max;

	public static int GetMask(int v)
	{
		// http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
		v |= v >> 1;
		v |= v >> 2;
		v |= v >> 4;
		v |= v >> 8;
		v |= v >> 16;
		return v;
	}

	public int GetVariableBits() => GetMask(this.Min ^ this.Max);
}

public class CiFloatingType : CiNumericType
{
	public override bool IsAssignableFrom(CiType right) => right is CiNumericType;
}

public abstract class CiNamedValue : CiSymbol
{
	internal CiExpr#? TypeExpr;
	internal CiExpr#? Value;
	public bool IsAssignableStorage() => this.Type is CiStorageType && !(this.Type is CiArrayStorageType) && this.Value is CiLiteralNull;
}

public abstract class CiMember : CiNamedValue
{
	internal CiVisibility Visibility;
	protected CiMember()
	{
	}
	public abstract bool IsStatic();
}

public class CiVar : CiNamedValue
{
	internal bool IsAssigned = false;
	public static CiVar# New(CiType#? type, string name, CiExpr#? defaultValue = null)
		=> new CiVar { Type = type, Name = name, Value = defaultValue };
	public override void Accept(CiVisitor! visitor, CiPriority parent) { visitor.VisitVar(this); }
	public CiVar!? NextParameter()
	{
		assert this.Next is CiVar! def;
		return def;
	}
}

public enum CiVisitStatus
{
	NotYet,
	InProgress,
	Done
}

public class CiConst : CiMember
{
	internal CiMethodBase? InMethod;
	internal CiVisitStatus VisitStatus;
	public override void AcceptStatement(CiVisitor! visitor) { visitor.VisitConst(this); }
	public override bool IsStatic() => true;
}

public class CiField : CiMember
{
	public override bool IsStatic() => false;
}

public class CiProperty : CiMember
{
	public override bool IsStatic() => false;
	public static CiProperty# New(CiType# type, CiId id, string name)
		=> new CiProperty { Visibility = CiVisibility.Public, Type = type, Id = id, Name = name };
}

public class CiStaticProperty : CiMember
{
	public override bool IsStatic() => true;
	public static CiStaticProperty# New(CiType# type, CiId id, string name)
		=> new CiStaticProperty { Visibility = CiVisibility.Public, Type = type, Id = id, Name = name };
}

public class CiMethodBase : CiMember
{
	internal bool IsMutator = false;
	internal bool Throws;
	internal CiStatement#? Body;
	internal bool IsLive = false;
	internal HashSet<CiMethod!>() Calls;
	public override bool IsStatic() => false; // constructor
}

public class CiMethod : CiMethodBase
{
	internal CiCallType CallType;
	internal CiParameters() Parameters;
	internal CiScope() MethodScope;
	public static CiMethod# New(CiVisibility visibility, CiType# type, CiId id, string name, CiVar#? param0 = null, CiVar#? param1 = null, CiVar#? param2 = null, CiVar#? param3 = null)
	{
		CiMethod# result = new CiMethod { Visibility = visibility, CallType = CiCallType.Normal, Type = type, Id = id, Name = name };
		if (param0 != null) {
			result.Parameters.Add(param0);
			if (param1 != null) {
				result.Parameters.Add(param1);
				if (param2 != null) {
					result.Parameters.Add(param2);
					if (param3 != null)
						result.Parameters.Add(param3);
				}
			}
		}
		return result;
	}
	public static CiMethod# NewStatic(CiType# type, CiId id, string name, CiVar#? param0, CiVar#? param1 = null, CiVar#? param2 = null)
	{
		CiMethod# result = New(CiVisibility.Public, type, id, name, param0, param1, param2);
		result.CallType = CiCallType.Static;
		return result;
	}
	public static CiMethod# NewMutator(CiVisibility visibility, CiType# type, CiId id, string name, CiVar#? param0 = null, CiVar#? param1 = null, CiVar#? param2 = null)
	{
		CiMethod# result = New(visibility, type, id, name, param0, param1, param2);
		result.IsMutator = true;
		return result;
	}
	public override bool IsStatic() => this.CallType == CiCallType.Static;
	public bool IsAbstractOrVirtual() => this.CallType == CiCallType.Abstract || this.CallType == CiCallType.Virtual;
	public CiMethod GetDeclaringMethod()
	{
		CiMethod method = this;
		while (method.CallType == CiCallType.Override) {
			assert method.Parent.Parent.TryLookup(method.Name, false) is CiMethod baseMethod;
			method = baseMethod;
		}
		return method;
	}
	public bool IsToString() => this.Name == "ToString" && this.CallType != CiCallType.Static && this.Parameters.Count() == 0;
}

public class CiMethodGroup : CiMember
{
	internal CiMethod#?[2] Methods;
	CiMethodGroup()
	{
	}
	public override bool IsStatic() { assert false; }
	public static CiMethodGroup# New(CiMethod# method0, CiMethod# method1)
	{
		CiMethodGroup# result = new CiMethodGroup { Visibility = method0.Visibility, Name = method0.Name };
		result.Methods[0] = method0;
		result.Methods[1] = method1;
		return result;
	}
}

public abstract class CiContainerType : CiType
{
	internal bool IsPublic;
	internal string() Filename;
}

public class CiEnum : CiContainerType
{
	internal bool HasExplicitValue = false;
	public void AcceptValues(CiVisitor! visitor)
	{
		CiConst? previous = null;
		for (CiSymbol? symbol = this.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiConst konst) { // not HasFlag
				visitor.VisitEnumValue(konst, previous);
				previous = konst;
			}
		}
	}
}

public class CiEnumFlags : CiEnum
{
}

public class CiClass : CiContainerType
{
	internal CiCallType CallType;
	internal int TypeParameterCount = 0;
	internal bool HasSubclasses = false;
	internal string() BaseClassName = "";
	internal CiMethodBase#? Constructor;
	internal List<CiConst>() ConstArrays;
	public bool HasBaseClass() => this.BaseClassName.Length > 0;
	public bool AddsVirtualMethods()
	{
		for (CiSymbol? symbol = this.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiMethod method && method.IsAbstractOrVirtual())
				return true;
		}
		return false;
	}

	public CiClass()
	{
		Add(CiVar.New(new CiReadWriteClassType { Class = this }, "this")); // shadows "this" in base class
	}

	public static CiClass# New(CiCallType callType, CiId id, string name, int typeParameterCount = 0)
		=> new CiClass { CallType = callType, Id = id, Name = name, TypeParameterCount = typeParameterCount };

	public bool IsSameOrBaseOf(CiClass derived)
	{
		while (derived != this) {
			if (derived.Parent is CiClass parent)
				derived = parent;
			else
				return false;
		}
		return true;
	}

	public bool HasToString() => TryLookup("ToString", false) is CiMethod method && method.IsToString();

	public bool AddsToString() => this.Dict.ContainsKey("ToString") && this.Dict["ToString"] is CiMethod method && method.IsToString()
		&& method.CallType != CiCallType.Override && method.CallType != CiCallType.Sealed;
}

public class CiClassType : CiType
{
	internal CiClass Class;
	internal CiType#? TypeArg0;
	internal CiType#? TypeArg1;
	public CiType# GetElementType() => this.TypeArg0;
	public CiType GetKeyType() => this.TypeArg0;
	public CiType# GetValueType() => this.TypeArg1;
	public override bool IsArray() => this.Class.Id == CiId.ArrayPtrClass;
	public override CiType GetBaseType() => IsArray() ? GetElementType().GetBaseType() : this;

	internal bool EqualTypeArguments(CiClassType right)
	{
		switch (this.Class.TypeParameterCount) {
		case 0: return true;
		case 1: return this.TypeArg0.EqualsType(right.TypeArg0);
		case 2: return this.TypeArg0.EqualsType(right.TypeArg0) && this.TypeArg1.EqualsType(right.TypeArg1);
		default: assert false;
		}
	}

	protected bool IsAssignableFromClass(CiClassType right) => this.Class.IsSameOrBaseOf(right.Class) && EqualTypeArguments(right);

	public override bool IsAssignableFrom(CiType right)
	{
		return (this.Nullable && right.Id == CiId.NullType)
			|| (right is CiClassType rightClass && IsAssignableFromClass(rightClass));
	}

	protected bool EqualsTypeInternal(CiClassType that) => this.Nullable == that.Nullable && this.Class == that.Class && EqualTypeArguments(that);

	public override bool EqualsType(CiType right)
		=> right is CiClassType that && !(right is CiReadWriteClassType) && EqualsTypeInternal(that);

	public override string() GetArraySuffix() => IsArray() ? "[]" : "";
	public virtual string GetClassSuffix() => "";
	string GetNullableSuffix() => this.Nullable ? "?" : "";

	public override string() ToString()
	{
		if (IsArray())
			return $"{GetElementType().GetBaseType()}{GetArraySuffix()}{GetNullableSuffix()}{GetElementType().GetArraySuffix()}";
		switch (this.Class.TypeParameterCount) {
		case 0: return $"{this.Class.Name}{GetClassSuffix()}{GetNullableSuffix()}";
		case 1: return $"{this.Class.Name}<{this.TypeArg0}>{GetClassSuffix()}{GetNullableSuffix()}";
		case 2: return $"{this.Class.Name}<{this.TypeArg0}, {this.TypeArg1}>{GetClassSuffix()}{GetNullableSuffix()}";
		default: assert false;
		}
	}
}

public class CiReadWriteClassType : CiClassType
{
	public override bool IsAssignableFrom(CiType right)
	{
		return (this.Nullable && right.Id == CiId.NullType)
			|| (right is CiReadWriteClassType rightClass && IsAssignableFromClass(rightClass));
	}

	public override bool EqualsType(CiType right)
		=> right is CiReadWriteClassType that && !(right is CiStorageType) && !(right is CiDynamicPtrType) && EqualsTypeInternal(that);

	public override string() GetArraySuffix() => IsArray() ? "[]!" : "";
	public override string GetClassSuffix() => "!";
}

public class CiStorageType : CiReadWriteClassType
{
	public override bool IsFinal() => this.Class.Id != CiId.MatchClass;
	public override bool IsAssignableFrom(CiType right) => right is CiStorageType rightClass && this.Class == rightClass.Class && EqualTypeArguments(rightClass);
	public override bool EqualsType(CiType right) => right is CiStorageType that && EqualsTypeInternal(that);
	public override string GetClassSuffix() => "()";
}

public class CiDynamicPtrType : CiReadWriteClassType
{
	public override bool IsAssignableFrom(CiType right)
	{
		return (this.Nullable && right.Id == CiId.NullType)
			|| (right is CiDynamicPtrType rightClass && IsAssignableFromClass(rightClass));
	}
	public override bool EqualsType(CiType right) => right is CiDynamicPtrType that && EqualsTypeInternal(that);

	public override string() GetArraySuffix() => IsArray() ? "[]#" : "";
	public override string GetClassSuffix() => "#";
}

public class CiArrayStorageType : CiStorageType
{
	internal CiExpr# LengthExpr;
	internal int Length;
	internal bool PtrTaken = false;

	public override CiType GetBaseType() => GetElementType().GetBaseType();
	public override bool IsArray() => true;
	public override string() GetArraySuffix() => $"[{this.Length}]";
	public override bool EqualsType(CiType right) => right is CiArrayStorageType that && GetElementType().EqualsType(that.GetElementType()) && this.Length == that.Length;
	public override CiType GetStorageType() => GetElementType().GetStorageType();
}

public class CiStringType : CiClassType
{
}

public class CiStringStorageType : CiStringType
{
	public override bool IsAssignableFrom(CiType right) => right is CiStringType;
	public override string GetClassSuffix() => "()";
}

public class CiPrintableType : CiType
{
	public override bool IsAssignableFrom(CiType right)
	{
		switch (right) {
		case CiNumericType _:
		case CiStringType _:
			return true;
		case CiClassType klass:
			return klass.Class.HasToString();
		default:
			return false;
		}
	}
}

public class CiSystem : CiScope
{
	internal CiType# VoidType = new CiType { Id = CiId.VoidType, Name = "void" };
	internal CiType# NullType = new CiType { Id = CiId.NullType, Name = "null", Nullable = true };
	CiType# TypeParam0 = new CiType { Id = CiId.TypeParam0, Name = "T" };
	internal CiIntegerType# IntType = new CiIntegerType { Id = CiId.IntType, Name = "int" };
	CiRangeType# UIntType = CiRangeType.New(0, int.MaxValue);
	internal CiIntegerType# LongType = new CiIntegerType { Id = CiId.LongType, Name = "long" };
	internal CiRangeType# ByteType = CiRangeType.New(0, 0xff);
	CiFloatingType# FloatType = new CiFloatingType { Id = CiId.FloatType, Name = "float" };
	internal CiFloatingType# DoubleType = new CiFloatingType { Id = CiId.DoubleType, Name = "double" };
	internal CiRangeType# CharType = CiRangeType.New(-0x80, 0xffff);
	internal CiEnum# BoolType = new CiEnum { Id = CiId.BoolType, Name = "bool" };
	CiClass# StringClass = CiClass.New(CiCallType.Normal, CiId.StringClass, "string");
	internal CiStringType# StringPtrType = new CiStringType { Id = CiId.StringPtrType, Name = "string" };
	internal CiStringType# StringNullablePtrType = new CiStringType { Id = CiId.StringPtrType, Name = "string", Nullable = true };
	internal CiStringStorageType# StringStorageType = new CiStringStorageType { Id = CiId.StringStorageType };
	internal CiType# PrintableType = new CiPrintableType { Name = "printable" };
	internal CiClass# ArrayPtrClass = CiClass.New(CiCallType.Normal, CiId.ArrayPtrClass, "ArrayPtr", 1);
	internal CiClass# ArrayStorageClass = CiClass.New(CiCallType.Normal, CiId.ArrayStorageClass, "ArrayStorage", 1);
	internal CiReadWriteClassType# LockPtrType = new CiReadWriteClassType();

	internal CiLiteralLong# NewLiteralLong(long value, int line = 0)
	{
		CiType# type = value >= int.MinValue && value <= int.MaxValue ? CiRangeType.New(value, value) : LongType;
		return new CiLiteralLong { Line = line, Type = type, Value = value };
	}

	internal CiLiteralString# NewLiteralString(string value, int line = 0) => new CiLiteralString { Line = line, Type = StringPtrType, Value = value };

	internal CiType# PromoteIntegerTypes(CiType left, CiType right)
	{
		return left == LongType || right == LongType ? LongType : IntType;
	}

	internal CiType#? PromoteFloatingTypes(CiType left, CiType right)
	{
		if (left.Id == CiId.DoubleType || right.Id == CiId.DoubleType)
			return DoubleType;
		if (left.Id == CiId.FloatType || right.Id == CiId.FloatType
		 || left.Id == CiId.FloatIntType || right.Id == CiId.FloatIntType)
			return FloatType;
		return null;
	}

	internal CiType# PromoteNumericTypes(CiType# left, CiType# right)
	{
		// TODO: PromoteFloatingTypes(left, right) ?? PromoteIntegerTypes(left, right);
		CiType#? result = PromoteFloatingTypes(left, right);
		return result != null ? result : PromoteIntegerTypes(left, right);
	}

	internal CiEnumFlags# NewEnumFlags()
	{
		CiEnumFlags# enu = new CiEnumFlags();
		enu.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.EnumHasFlag, "HasFlag", CiVar.New(enu, "flag")));
		return enu;
	}

	CiClass! AddCollection!(CiId id, string name, int typeParameterCount, CiId clearId, CiId countId)
	{
		CiClass# result = CiClass.New(CiCallType.Normal, id, name, typeParameterCount);
		result.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, clearId, "Clear"));
		result.Add(CiProperty.New(UIntType, countId, "Count"));
		Add(result);
		return result;
	}

	void AddSet!(CiId id, string name, CiId addId, CiId clearId, CiId containsId, CiId countId, CiId removeId)
	{
		CiClass! set = AddCollection(id, name, 1, clearId, countId);
		set.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, addId, "Add", CiVar.New(TypeParam0, "value")));
		set.Add(CiMethod.New(CiVisibility.Public, BoolType, containsId, "Contains", CiVar.New(TypeParam0, "value")));
		set.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, removeId, "Remove", CiVar.New(TypeParam0, "value")));
	}

	void AddDictionary!(CiId id, string name, CiId clearId, CiId containsKeyId, CiId countId, CiId removeId)
	{
		CiClass! dict = AddCollection(id, name, 2, clearId, countId);
		dict.Add(CiMethod.NewMutator(CiVisibility.FinalValueType, VoidType, CiId.DictionaryAdd, "Add", CiVar.New(TypeParam0, "key")));
		dict.Add(CiMethod.New(CiVisibility.Public, BoolType, containsKeyId, "ContainsKey", CiVar.New(TypeParam0, "key")));
		dict.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, removeId, "Remove", CiVar.New(TypeParam0, "key")));
	}

	static void AddEnumValue(CiEnum# enu, CiConst# value)
	{
		value.Type = enu;
		enu.Add(value);
	}

	CiConst# NewConstLong(string name, long value)
	{
		CiConst# result = new CiConst { Visibility = CiVisibility.Public, Name = name, Value = NewLiteralLong(value), VisitStatus = CiVisitStatus.Done };
		result.Type = result.Value.Type;
		return result;
	}

	CiConst# NewConstDouble(string name, double value)
		=> new CiConst { Visibility = CiVisibility.Public, Name = name, Value = new CiLiteralDouble { Value = value, Type = DoubleType }, Type = DoubleType, VisitStatus = CiVisitStatus.Done };

	void AddMinMaxValue(CiIntegerType! target, long min, long max)
	{
		target.Add(NewConstLong("MinValue", min));
		target.Add(NewConstLong("MaxValue", max));
	}

	CiSystem()
	{
		Parent = null;
		CiSymbol# basePtr = CiVar.New(null, "base");
		basePtr.Id = CiId.BasePtr;
		Add(basePtr);
		AddMinMaxValue(IntType, int.MinValue, int.MaxValue);
		IntType.Add(CiMethod.NewMutator(CiVisibility.Public, BoolType, CiId.IntTryParse, "TryParse", CiVar.New(StringPtrType, "value"), CiVar.New(IntType, "radix", NewLiteralLong(0))));
		Add(IntType);
		UIntType.Name = "uint";
		Add(UIntType);
		AddMinMaxValue(LongType, long.MinValue, long.MaxValue);
		LongType.Add(CiMethod.NewMutator(CiVisibility.Public, BoolType, CiId.LongTryParse, "TryParse", CiVar.New(StringPtrType, "value"), CiVar.New(IntType, "radix", NewLiteralLong(0))));
		Add(LongType);
		ByteType.Name = "byte";
		Add(ByteType);
		CiRangeType# shortType = CiRangeType.New(-0x8000, 0x7fff);
		shortType.Name = "short";
		Add(shortType);
		CiRangeType# ushortType = CiRangeType.New(0, 0xffff);
		ushortType.Name = "ushort";
		Add(ushortType);
		CiRangeType# minus1Type = CiRangeType.New(-1, int.MaxValue);
		Add(FloatType);
		DoubleType.Add(CiMethod.NewMutator(CiVisibility.Public, BoolType, CiId.DoubleTryParse, "TryParse", CiVar.New(StringPtrType, "value")));
		Add(DoubleType);
		Add(BoolType);
		StringClass.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.StringContains, "Contains", CiVar.New(StringPtrType, "value")));
		StringClass.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.StringEndsWith, "EndsWith", CiVar.New(StringPtrType, "value")));
		StringClass.Add(CiMethod.New(CiVisibility.Public, minus1Type, CiId.StringIndexOf, "IndexOf", CiVar.New(StringPtrType, "value")));
		StringClass.Add(CiMethod.New(CiVisibility.Public, minus1Type, CiId.StringLastIndexOf, "LastIndexOf", CiVar.New(StringPtrType, "value")));
		StringClass.Add(CiProperty.New(UIntType, CiId.StringLength, "Length"));
		StringClass.Add(CiMethod.New(CiVisibility.Public, StringStorageType, CiId.StringReplace, "Replace", CiVar.New(StringPtrType, "oldValue"), CiVar.New(StringPtrType, "newValue")));
		StringClass.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.StringStartsWith, "StartsWith", CiVar.New(StringPtrType, "value")));
		StringClass.Add(CiMethod.New(CiVisibility.Public, StringStorageType, CiId.StringSubstring, "Substring", CiVar.New(IntType, "offset"), CiVar.New(IntType, "length", NewLiteralLong(-1)))); // TODO: UIntType
		StringPtrType.Class = StringClass;
		Add(StringPtrType);
		StringNullablePtrType.Class = StringClass;
		StringStorageType.Class = StringClass;
		CiMethod# arrayBinarySearchPart = CiMethod.New(CiVisibility.NumericElementType, IntType, CiId.ArrayBinarySearchPart, "BinarySearch",
			CiVar.New(TypeParam0, "value"), CiVar.New(IntType, "startIndex"), CiVar.New(IntType, "count"));
		ArrayPtrClass.Add(arrayBinarySearchPart);
		ArrayPtrClass.Add(CiMethod.New(CiVisibility.Public, VoidType, CiId.ArrayCopyTo, "CopyTo", CiVar.New(IntType, "sourceIndex"),
			CiVar.New(new CiReadWriteClassType { Class = ArrayPtrClass, TypeArg0 = TypeParam0 }, "destinationArray"), CiVar.New(IntType, "destinationIndex"), CiVar.New(IntType, "count")));
		CiMethod# arrayFillPart = CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ArrayFillPart, "Fill",
			CiVar.New(TypeParam0, "value"), CiVar.New(IntType, "startIndex"), CiVar.New(IntType, "count"));
		ArrayPtrClass.Add(arrayFillPart);
		CiMethod# arraySortPart = CiMethod.NewMutator(CiVisibility.NumericElementType, VoidType, CiId.ArraySortPart, "Sort", CiVar.New(IntType, "startIndex"), CiVar.New(IntType, "count"));
		ArrayPtrClass.Add(arraySortPart);
		ArrayStorageClass.Parent = ArrayPtrClass;
		ArrayStorageClass.Add(CiMethodGroup.New(CiMethod.New(CiVisibility.NumericElementType, IntType, CiId.ArrayBinarySearchAll, "BinarySearch", CiVar.New(TypeParam0, "value")),
			arrayBinarySearchPart));
		ArrayStorageClass.Add(CiMethodGroup.New(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ArrayFillAll, "Fill", CiVar.New(TypeParam0, "value")),
			arrayFillPart));
		ArrayStorageClass.Add(CiProperty.New(UIntType, CiId.ArrayLength, "Length"));
		ArrayStorageClass.Add(CiMethodGroup.New(
			CiMethod.NewMutator(CiVisibility.NumericElementType, VoidType, CiId.ArraySortAll, "Sort"),
			arraySortPart));

		CiType# typeParam0NotFinal = new CiType { Id = CiId.TypeParam0NotFinal, Name = "T" };
		CiType# typeParam0Predicate = new CiType { Id = CiId.TypeParam0Predicate, Name = "Predicate<T>" };
		CiClass! listClass = AddCollection(CiId.ListClass, "List", 1, CiId.ListClear, CiId.ListCount);
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ListAdd, "Add", CiVar.New(typeParam0NotFinal, "value")));
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ListAddRange, "AddRange", CiVar.New(new CiClassType { Class = listClass, TypeArg0 = TypeParam0 }, "source")));
		listClass.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.ListAll, "All", CiVar.New(typeParam0Predicate, "predicate")));
		listClass.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.ListAny, "Any", CiVar.New(typeParam0Predicate, "predicate")));
		listClass.Add(CiMethod.New(CiVisibility.Public, BoolType, CiId.ListContains, "Contains", CiVar.New(TypeParam0, "value")));
		listClass.Add(CiMethod.New(CiVisibility.Public, VoidType, CiId.ListCopyTo, "CopyTo", CiVar.New(IntType, "sourceIndex"),
			CiVar.New(new CiReadWriteClassType { Class = ArrayPtrClass, TypeArg0 = TypeParam0 }, "destinationArray"), CiVar.New(IntType, "destinationIndex"), CiVar.New(IntType, "count")));
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, IntType, CiId.ListIndexOf, "IndexOf", CiVar.New(TypeParam0, "value")));
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ListInsert, "Insert", CiVar.New(UIntType, "index"), CiVar.New(typeParam0NotFinal, "value")));
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, TypeParam0, CiId.ListLast, "Last"));
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ListRemoveAt, "RemoveAt", CiVar.New(IntType, "index")));
		listClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.ListRemoveRange, "RemoveRange", CiVar.New(IntType, "index"), CiVar.New(IntType, "count")));
		listClass.Add(CiMethodGroup.New(
			CiMethod.NewMutator(CiVisibility.NumericElementType, VoidType, CiId.ListSortAll, "Sort"),
			CiMethod.NewMutator(CiVisibility.NumericElementType, VoidType, CiId.ListSortPart, "Sort", CiVar.New(IntType, "startIndex"), CiVar.New(IntType, "count"))));
		CiClass! queueClass = AddCollection(CiId.QueueClass, "Queue", 1, CiId.QueueClear, CiId.QueueCount);
		queueClass.Add(CiMethod.NewMutator(CiVisibility.Public, TypeParam0, CiId.QueueDequeue, "Dequeue"));
		queueClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.QueueEnqueue, "Enqueue", CiVar.New(TypeParam0, "value")));
		queueClass.Add(CiMethod.New(CiVisibility.Public, TypeParam0, CiId.QueuePeek, "Peek"));
		CiClass! stackClass = AddCollection(CiId.StackClass, "Stack", 1, CiId.StackClear, CiId.StackCount);
		stackClass.Add(CiMethod.New(CiVisibility.Public, TypeParam0, CiId.StackPeek, "Peek"));
		stackClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.StackPush, "Push", CiVar.New(TypeParam0, "value")));
		stackClass.Add(CiMethod.NewMutator(CiVisibility.Public, TypeParam0, CiId.StackPop, "Pop"));
		AddSet(CiId.HashSetClass, "HashSet", CiId.HashSetAdd, CiId.HashSetClear, CiId.HashSetContains, CiId.HashSetCount, CiId.HashSetRemove);
		AddSet(CiId.SortedSetClass, "SortedSet", CiId.SortedSetAdd, CiId.SortedSetClear, CiId.SortedSetContains, CiId.SortedSetCount, CiId.SortedSetRemove);
		AddDictionary(CiId.DictionaryClass, "Dictionary", CiId.DictionaryClear, CiId.DictionaryContainsKey, CiId.DictionaryCount, CiId.DictionaryRemove);
		AddDictionary(CiId.SortedDictionaryClass, "SortedDictionary", CiId.SortedDictionaryClear, CiId.SortedDictionaryContainsKey, CiId.SortedDictionaryCount, CiId.SortedDictionaryRemove);
		AddDictionary(CiId.OrderedDictionaryClass, "OrderedDictionary", CiId.OrderedDictionaryClear, CiId.OrderedDictionaryContainsKey, CiId.OrderedDictionaryCount, CiId.OrderedDictionaryRemove);

		CiClass# textWriterClass = CiClass.New(CiCallType.Normal, CiId.TextWriterClass, "TextWriter");
		textWriterClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.TextWriterWrite, "Write", CiVar.New(PrintableType, "value")));
		textWriterClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.TextWriterWriteChar, "WriteChar", CiVar.New(IntType, "c")));
		textWriterClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.TextWriterWriteLine, "WriteLine", CiVar.New(PrintableType, "value", NewLiteralString(""))));
		Add(textWriterClass);
		CiClass# consoleClass = CiClass.New(CiCallType.Static, CiId.None, "Console");
		consoleClass.Add(CiMethod.NewStatic(VoidType, CiId.ConsoleWrite, "Write", CiVar.New(PrintableType, "value")));
		consoleClass.Add(CiMethod.NewStatic(VoidType, CiId.ConsoleWriteLine, "WriteLine", CiVar.New(PrintableType, "value", NewLiteralString(""))));
		consoleClass.Add(CiStaticProperty.New(new CiStorageType { Class = textWriterClass }, CiId.ConsoleError, "Error"));
		Add(consoleClass);
		CiClass# stringWriterClass = CiClass.New(CiCallType.Sealed, CiId.StringWriterClass, "StringWriter");
		stringWriterClass.Add(CiMethod.NewMutator(CiVisibility.Public, VoidType, CiId.StringWriterClear, "Clear"));
		stringWriterClass.Add(CiMethod.New(CiVisibility.Public, StringPtrType, CiId.StringWriterToString, "ToString"));
		Add(stringWriterClass);
		stringWriterClass.Parent = textWriterClass;
		CiClass# utf8EncodingClass = CiClass.New(CiCallType.Sealed, CiId.None, "UTF8Encoding");
		utf8EncodingClass.Add(CiMethod.New(CiVisibility.Public, IntType, CiId.UTF8GetByteCount, "GetByteCount", CiVar.New(StringPtrType, "str")));
		utf8EncodingClass.Add(CiMethod.New(CiVisibility.Public, VoidType, CiId.UTF8GetBytes, "GetBytes",
			CiVar.New(StringPtrType, "str"), CiVar.New(new CiReadWriteClassType { Class = ArrayPtrClass, TypeArg0 = ByteType }, "bytes"), CiVar.New(IntType, "byteIndex")));
		utf8EncodingClass.Add(CiMethod.New(CiVisibility.Public, StringStorageType, CiId.UTF8GetString, "GetString",
			CiVar.New(new CiClassType { Class = ArrayPtrClass, TypeArg0 = ByteType }, "bytes"), CiVar.New(IntType, "offset"), CiVar.New(IntType, "length"))); // TODO: UIntType
		CiClass# encodingClass = CiClass.New(CiCallType.Static, CiId.None, "Encoding");
		encodingClass.Add(CiStaticProperty.New(utf8EncodingClass, CiId.None, "UTF8"));
		Add(encodingClass);
		CiClass# environmentClass = CiClass.New(CiCallType.Static, CiId.None, "Environment");
		environmentClass.Add(CiMethod.NewStatic(StringNullablePtrType, CiId.EnvironmentGetEnvironmentVariable, "GetEnvironmentVariable", CiVar.New(StringPtrType, "name")));
		Add(environmentClass);
		CiEnumFlags# regexOptionsEnum = NewEnumFlags();
		regexOptionsEnum.Id = CiId.RegexOptionsEnum;
		regexOptionsEnum.Name = "RegexOptions";
		CiConst# regexOptionsNone = NewConstLong("None", 0);
		AddEnumValue(regexOptionsEnum, regexOptionsNone);
		AddEnumValue(regexOptionsEnum, NewConstLong("IgnoreCase", 1));
		AddEnumValue(regexOptionsEnum, NewConstLong("Multiline", 2));
		AddEnumValue(regexOptionsEnum, NewConstLong("Singleline", 16));
		Add(regexOptionsEnum);
		CiClass# regexClass = CiClass.New(CiCallType.Sealed, CiId.RegexClass, "Regex");
		regexClass.Add(CiMethod.NewStatic(StringStorageType, CiId.RegexEscape, "Escape", CiVar.New(StringPtrType, "str")));
		regexClass.Add(CiMethodGroup.New(
				CiMethod.NewStatic(BoolType, CiId.RegexIsMatchStr, "IsMatch", CiVar.New(StringPtrType, "input"), CiVar.New(StringPtrType, "pattern"), CiVar.New(regexOptionsEnum, "options", regexOptionsNone)),
				CiMethod.New(CiVisibility.Public, BoolType, CiId.RegexIsMatchRegex, "IsMatch", CiVar.New(StringPtrType, "input"))));
		regexClass.Add(CiMethod.NewStatic(new CiDynamicPtrType { Class = regexClass }, CiId.RegexCompile, "Compile", CiVar.New(StringPtrType, "pattern"), CiVar.New(regexOptionsEnum, "options", regexOptionsNone)));
		Add(regexClass);
		CiClass# matchClass = CiClass.New(CiCallType.Sealed, CiId.MatchClass, "Match");
		matchClass.Add(CiMethodGroup.New(
				CiMethod.NewMutator(CiVisibility.Public, BoolType, CiId.MatchFindStr, "Find", CiVar.New(StringPtrType, "input"), CiVar.New(StringPtrType, "pattern"), CiVar.New(regexOptionsEnum, "options", regexOptionsNone)),
				CiMethod.NewMutator(CiVisibility.Public, BoolType, CiId.MatchFindRegex, "Find", CiVar.New(StringPtrType, "input"), CiVar.New(new CiClassType { Class = regexClass }, "pattern"))));
		matchClass.Add(CiProperty.New(IntType, CiId.MatchStart, "Start"));
		matchClass.Add(CiProperty.New(IntType, CiId.MatchEnd, "End"));
		matchClass.Add(CiMethod.New(CiVisibility.Public, StringPtrType, CiId.MatchGetCapture, "GetCapture", CiVar.New(UIntType, "group")));
		matchClass.Add(CiProperty.New(UIntType, CiId.MatchLength, "Length"));
		matchClass.Add(CiProperty.New(StringPtrType, CiId.MatchValue, "Value"));
		Add(matchClass);

		CiFloatingType# floatIntType = new CiFloatingType { Id = CiId.FloatIntType, Name = "float" };
		CiClass# mathClass = CiClass.New(CiCallType.Static, CiId.None, "Math");
		mathClass.Add(CiMethodGroup.New(
				CiMethod.NewStatic(IntType, CiId.MathAbs, "Abs", CiVar.New(LongType, "a")),
				CiMethod.NewStatic(FloatType, CiId.MathAbs, "Abs", CiVar.New(DoubleType, "a"))));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Acos", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Asin", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Atan", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Atan2", CiVar.New(DoubleType, "y"), CiVar.New(DoubleType, "x")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Cbrt", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(floatIntType, CiId.MathCeiling, "Ceiling", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethodGroup.New(
				CiMethod.NewStatic(IntType, CiId.MathClamp, "Clamp", CiVar.New(LongType, "value"), CiVar.New(LongType, "min"), CiVar.New(LongType, "max")),
				CiMethod.NewStatic(FloatType, CiId.MathClamp, "Clamp", CiVar.New(DoubleType, "value"), CiVar.New(DoubleType, "min"), CiVar.New(DoubleType, "max"))));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Cos", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Cosh", CiVar.New(DoubleType, "a")));
		mathClass.Add(NewConstDouble("E", Math.E));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Exp", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(floatIntType, CiId.MathMethod, "Floor", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathFusedMultiplyAdd, "FusedMultiplyAdd", CiVar.New(DoubleType, "x"), CiVar.New(DoubleType, "y"), CiVar.New(DoubleType, "z")));
		mathClass.Add(CiMethod.NewStatic(BoolType, CiId.MathIsFinite, "IsFinite", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(BoolType, CiId.MathIsInfinity, "IsInfinity", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(BoolType, CiId.MathIsNaN, "IsNaN", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Log", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathLog2, "Log2", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Log10", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethodGroup.New(
				CiMethod.NewStatic(IntType, CiId.MathMaxInt, "Max", CiVar.New(LongType, "a"), CiVar.New(LongType, "b")),
				CiMethod.NewStatic(FloatType, CiId.MathMaxDouble, "Max", CiVar.New(DoubleType, "a"), CiVar.New(DoubleType, "b"))));
		mathClass.Add(CiMethodGroup.New(
				CiMethod.NewStatic(IntType, CiId.MathMinInt, "Min", CiVar.New(LongType, "a"), CiVar.New(LongType, "b")),
				CiMethod.NewStatic(FloatType, CiId.MathMinDouble, "Min", CiVar.New(DoubleType, "a"), CiVar.New(DoubleType, "b"))));
		mathClass.Add(CiStaticProperty.New(FloatType, CiId.MathNaN, "NaN"));
		mathClass.Add(CiStaticProperty.New(FloatType, CiId.MathNegativeInfinity, "NegativeInfinity"));
		mathClass.Add(NewConstDouble("PI", Math.PI));
		mathClass.Add(CiStaticProperty.New(FloatType, CiId.MathPositiveInfinity, "PositiveInfinity"));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Pow", CiVar.New(DoubleType, "x"), CiVar.New(DoubleType, "y")));
		mathClass.Add(CiMethod.NewStatic(floatIntType, CiId.MathRound, "Round", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Sin", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Sinh", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Sqrt", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Tan", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(FloatType, CiId.MathMethod, "Tanh", CiVar.New(DoubleType, "a")));
		mathClass.Add(CiMethod.NewStatic(floatIntType, CiId.MathTruncate, "Truncate", CiVar.New(DoubleType, "a")));
		Add(mathClass);

		CiClass# lockClass = CiClass.New(CiCallType.Sealed, CiId.LockClass, "Lock");
		Add(lockClass);
		LockPtrType.Class = lockClass;
	}

	internal static CiSystem# New() => new CiSystem();
}

public class CiProgram : CiScope
{
	internal CiSystem System;
	internal List<string()>() TopLevelNatives;
	internal List<CiClass!>() Classes;
	internal SortedDictionary<string(), List<byte>()>() Resources;
}
