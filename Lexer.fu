// Lexer.fu - Fusion lexer
//
// Copyright (C) 2011-2023  Piotr Fusik
//
// This file is part of CiTo, see https://github.com/pfusik/cito
//
// CiTo is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiTo is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiTo.  If not, see http://www.gnu.org/licenses/

public abstract class CiParserHost
{
	public abstract void ReportError!(string filename, int startLine, int startColumn, int endLine, int endColumn, string message);
}

public enum CiToken
{
	EndOfFile,
	Id,
	LiteralLong,
	LiteralDouble,
	LiteralChar,
	LiteralString,
	InterpolatedString,
	Semicolon,
	Dot,
	Comma,
	LeftParenthesis,
	RightParenthesis,
	LeftBracket,
	RightBracket,
	LeftBrace,
	RightBrace,
	Plus,
	Minus,
	Asterisk,
	Slash,
	Mod,
	And,
	Or,
	Xor,
	Tilde,
	ShiftLeft,
	ShiftRight,
	Equal,
	NotEqual,
	Less,
	LessOrEqual,
	Greater,
	GreaterOrEqual,
	RightAngle,
	CondAnd,
	CondOr,
	ExclamationMark,
	Hash,
	Assign,
	AddAssign,
	SubAssign,
	MulAssign,
	DivAssign,
	ModAssign,
	AndAssign,
	OrAssign,
	XorAssign,
	ShiftLeftAssign,
	ShiftRightAssign,
	Increment,
	Decrement,
	QuestionMark,
	Colon,
	FatArrow,
	Range,
	DocRegular,
	DocBullet,
	DocBlank,
	Abstract,
	Assert,
	Break,
	Case,
	Class,
	Const,
	Continue,
	Default,
	Do,
	Else,
	Enum,
	False,
	For,
	Foreach,
	If,
	In,
	Internal,
	Is,
	Lock_,
	Native,
	New,
	Null,
	Override,
	Protected,
	Public,
	Resource,
	Return,
	Sealed,
	Static,
	Switch,
	Throw,
	Throws,
	True,
	Virtual,
	Void,
	When,
	While,
	EndOfLine,
	PreIf,
	PreElIf,
	PreElse,
	PreEndIf
}

enum CiPreState
{
	NotYet,
	Already,
	AlreadyElse
}

public abstract class CiLexer
{
	protected byte[] Input;
	int InputLength;
	int NextOffset;
	protected int CharOffset;
	int NextChar;
	CiParserHost! Host;
	protected string() Filename;
	protected int Line;
	protected int Column;
	protected int TokenColumn;
	protected int LexemeOffset;
	protected CiToken CurrentToken;
	protected long LongValue; // for CiToken.LiteralLong, CiToken.LiteralChar
	protected string() StringValue; // for CiToken.LiteralString, CiToken.InterpolatedString, CiToken.Id
	HashSet<string()>() PreSymbols;
	bool AtLineStart = true;
	bool LineMode = false;
	bool EnableDocComments = true;
	protected bool ParsingTypeArg = false;
	Stack<bool>() PreElseStack;

	public void SetHost!(CiParserHost! host)
	{
		this.Host = host;
	}

	public void AddPreSymbol!(string symbol)
	{
		this.PreSymbols.Add(symbol);
	}

	protected void Open!(string filename, byte[] input, int inputLength)
	{
		this.Filename = filename;
		this.Input = input;
		this.InputLength = inputLength;
		this.NextOffset = 0;
		this.Line = 1;
		this.Column = 1;
		FillNextChar();
		if (this.NextChar == 0xfeff) // BOM
			FillNextChar();
		NextToken();
	}

	protected void ReportError(string message)
	{
		this.Host.ReportError(this.Filename, this.Line, this.TokenColumn, this.Line, this.Column, message);
	}

	int ReadByte!()
	{
		if (this.NextOffset >= this.InputLength)
			return -1;
		return this.Input[this.NextOffset++];
	}

	const int ReplacementChar = 0xfffd;

	int ReadContinuationByte!(int hi)
	{
		int b = ReadByte();
		if (hi != ReplacementChar) {
			if (b >= 0x80 && b <= 0xbf)
				return (hi << 6) + b - 0x80;
			ReportError("Invalid UTF-8");
		}
		return ReplacementChar;
	}

	void FillNextChar!()
	{
		this.CharOffset = NextOffset;
		int b = ReadByte();
		if (b >= 0x80) {
			if (b < 0xc2 || b > 0xf4) {
				ReportError("Invalid UTF-8");
				b = ReplacementChar;
			}
			else if (b < 0xe0)
				b = ReadContinuationByte(b - 0xc0);
			else if (b < 0xf0) {
				b = ReadContinuationByte(b - 0xe0);
				b = ReadContinuationByte(b);
			}
			else {
				b = ReadContinuationByte(b - 0xf0);
				b = ReadContinuationByte(b);
				b = ReadContinuationByte(b);
			}
		}
		this.NextChar = b;
	}

	protected int PeekChar() => this.NextChar;

	public static bool IsLetterOrDigit(int c)
	{
		if (c >= 'a' && c <= 'z') return true;
		if (c >= 'A' && c <= 'Z') return true;
		if (c >= '0' && c <= '9') return true;
		return c == '_';
	}

	protected int ReadChar!()
	{
		int c = this.NextChar;
		switch (c) {
		case '\t':
		case ' ':
			this.Column++;
			break;
		case '\n':
			this.Line++;
			this.Column = 1;
			this.AtLineStart = true;
			break;
		default:
			this.Column++;
			this.AtLineStart = false;
			break;
		}
		FillNextChar();
		return c;
	}

	bool EatChar!(int c)
	{
		if (PeekChar() == c) {
			ReadChar();
			return true;
		}
		return false;
	}

	void SkipWhitespace!()
	{
		while (PeekChar() == '\t' || PeekChar() == ' ' || PeekChar() == '\r')
			ReadChar();
	}

	CiToken ReadIntegerLiteral!(int bits)
	{
		bool invalidDigit = false;
		bool tooBig = false;
		bool needDigit = true;
		for (long i = 0;; ReadChar()) {
			int c = PeekChar();
			if (c >= '0' && c <= '9')
				c -= '0';
			else if (c >= 'A' && c <= 'Z')
				c -= 'A' - 10;
			else if (c >= 'a' && c <= 'z')
				c -= 'a' - 10;
			else if (c == '_') {
				needDigit = true;
				continue;
			}
			else {
				this.LongValue = i;
				if (invalidDigit || needDigit)
					ReportError("Invalid integer");
				else if (tooBig)
					ReportError("Integer too big");
				return CiToken.LiteralLong;
			}
			if (c >= 1 << bits)
				invalidDigit = true;
			else if (i >> (64 - bits) != 0)
				tooBig = true;
			else
				i = (i << bits) + c;
			needDigit = false;
		}
	}

	CiToken ReadFloatLiteral!(bool needDigit)
	{
		bool underscoreE = false;
		bool exponent = false;
		for (;;) {
			int c = PeekChar();
			switch (c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				ReadChar();
				needDigit = false;
				break;
			case 'E':
			case 'e':
				if (exponent) {
					ReportError("Invalid floating-point number");
					return CiToken.LiteralDouble;
				}
				if (needDigit)
					underscoreE = true;
				ReadChar();
				c = PeekChar();
				if (c == '+' || c == '-')
					ReadChar();
				exponent = true;
				needDigit = true;
				break;
			case '_':
				ReadChar();
				needDigit = true;
				break;
			default:
				if (underscoreE
				 || needDigit
				 || (c >= 'A' && c <= 'Z')
				 || (c >= 'a' && c <= 'z'))
					ReportError("Invalid floating-point number");
				return CiToken.LiteralDouble;
			}
		}
	}

	CiToken ReadNumberLiteral!(long i)
	{
		bool leadingZero = false;
		bool tooBig = false;
		for (bool needDigit = false; ; ReadChar()) {
			int c = PeekChar();
			switch (c) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				c -= '0';
				break;
			case '.':
				ReadChar();
				return ReadFloatLiteral(true);
			case 'e':
			case 'E':
				return ReadFloatLiteral(needDigit);
			case '_':
				needDigit = true;
				continue;
			default:
				this.LongValue = i;
				if (leadingZero)
					ReportError("Leading zeros are not permitted, octal numbers must begin with 0o");
				if (needDigit
				 || (c >= 'A' && c <= 'Z')
				 || (c >= 'a' && c <= 'z'))
					ReportError("Invalid integer");
				else if (tooBig)
					ReportError("Integer too big");
				return CiToken.LiteralLong;
			}
			if (i == 0)
				leadingZero = true;
			if (i > (c < 8 ? 922337203685477580 : 922337203685477579))
				tooBig = true;
			else
				i = 10 * i + c;
			needDigit = false;
		}
	}

	public static int GetEscapedChar(int c)
	{
		switch (c) {
		case '"': return '"';
		case '\'': return '\'';
		case '\\': return '\\';
		case 'n': return '\n';
		case 'r': return '\r';
		case 't': return '\t';
		default: return -1;
		}
	}

	int ReadCharLiteral!()
	{
		int c = ReadChar();
		if (c < 32) {
			ReportError("Invalid character in literal");
			return ReplacementChar;
		}
		if (c != '\\')
			return c;
		c = GetEscapedChar(ReadChar());
		if (c < 0) {
			ReportError("Unknown escape sequence");
			return ReplacementChar;
		}
		return c;
	}

	protected CiToken ReadString!(bool interpolated)
	{
		for (int offset = this.CharOffset; ; ReadCharLiteral()) {
			switch (PeekChar()) {
			case -1:
				ReportError("Unterminated string literal");
				return CiToken.EndOfFile;
			case '\n':
				ReportError("Unterminated string literal");
				this.StringValue = "";
				return CiToken.LiteralString;
			case '"':
				{
					int endOffset = this.CharOffset;
					ReadChar();
					this.StringValue = Encoding.UTF8.GetString(this.Input, offset, endOffset - offset);
				}
				return CiToken.LiteralString;
			case '{':
				if (interpolated) {
					int endOffset = this.CharOffset;
					ReadChar();
					if (PeekChar() != '{') {
						this.StringValue = Encoding.UTF8.GetString(this.Input, offset, endOffset - offset);
						return CiToken.InterpolatedString;
					}
				}
				break;
			default:
				break;
			}
		}
	}

	protected string() GetLexeme() => Encoding.UTF8.GetString(this.Input, this.LexemeOffset, this.CharOffset - this.LexemeOffset);

	void ReadId!(int c)
	{
		if (IsLetterOrDigit(c)) {
			while (IsLetterOrDigit(PeekChar()))
				ReadChar();
			this.StringValue = GetLexeme();
		}
		else {
			ReportError("Invalid character");
			this.StringValue = "";
		}
	}

	CiToken ReadPreToken!()
	{
		for (;;) {
			bool atLineStart = this.AtLineStart;
			this.TokenColumn = this.Column;
			this.LexemeOffset = this.CharOffset;
			int c = ReadChar();
			switch (c) {
			case -1:
				return CiToken.EndOfFile;
			case '\t':
			case '\r':
			case ' ':
				break;
			case '\n':
				if (this.LineMode)
					return CiToken.EndOfLine;
				break;
			case '#':
				if (!atLineStart)
					return CiToken.Hash;
				this.LexemeOffset = this.CharOffset;
				ReadId(ReadChar());
				switch (this.StringValue) {
				case "if": return CiToken.PreIf;
				case "elif": return CiToken.PreElIf;
				case "else": return CiToken.PreElse;
				case "endif": return CiToken.PreEndIf;
				default:
					ReportError("Unknown preprocessor directive");
					continue;
				}
			case ';': return CiToken.Semicolon;
			case '.':
				if (EatChar('.')) return CiToken.Range;
				return CiToken.Dot;
			case ',': return CiToken.Comma;
			case '(': return CiToken.LeftParenthesis;
			case ')': return CiToken.RightParenthesis;
			case '[': return CiToken.LeftBracket;
			case ']': return CiToken.RightBracket;
			case '{': return CiToken.LeftBrace;
			case '}': return CiToken.RightBrace;
			case '~': return CiToken.Tilde;
			case '?': return CiToken.QuestionMark;
			case ':': return CiToken.Colon;
			case '+':
				if (EatChar('+')) return CiToken.Increment;
				if (EatChar('=')) return CiToken.AddAssign;
				return CiToken.Plus;
			case '-':
				if (EatChar('-')) return CiToken.Decrement;
				if (EatChar('=')) return CiToken.SubAssign;
				return CiToken.Minus;
			case '*':
				if (EatChar('=')) return CiToken.MulAssign;
				return CiToken.Asterisk;
			case '/':
				if (EatChar('/')) {
					c = ReadChar();
					if (c == '/' && this.EnableDocComments) {
						SkipWhitespace();
						switch (PeekChar()) {
						case '\n':
							return CiToken.DocBlank;
						case '*':
							ReadChar();
							SkipWhitespace();
							return CiToken.DocBullet;
						default:
							return CiToken.DocRegular;
						}
					}
					while (c != '\n' && c >= 0)
						c = ReadChar();
					if (c == '\n' && this.LineMode) return CiToken.EndOfLine;
					break;
				}
				if (EatChar('*')) {
					int startLine = this.Line;
					do {
						c = ReadChar();
						if (c < 0) {
							ReportError($"Unterminated multi-line comment, started in line {startLine}");
							return CiToken.EndOfFile;
						}
					} while (c != '*' || PeekChar() != '/');
					ReadChar();
					break;
				}
				if (EatChar('=')) return CiToken.DivAssign;
				return CiToken.Slash;
			case '%':
				if (EatChar('=')) return CiToken.ModAssign;
				return CiToken.Mod;
			case '&':
				if (EatChar('&')) return CiToken.CondAnd;
				if (EatChar('=')) return CiToken.AndAssign;
				return CiToken.And;
			case '|':
				if (EatChar('|')) return CiToken.CondOr;
				if (EatChar('=')) return CiToken.OrAssign;
				return CiToken.Or;
			case '^':
				if (EatChar('=')) return CiToken.XorAssign;
				return CiToken.Xor;
			case '=':
				if (EatChar('=')) return CiToken.Equal;
				if (EatChar('>')) return CiToken.FatArrow;
				return CiToken.Assign;
			case '!':
				if (EatChar('=')) return CiToken.NotEqual;
				return CiToken.ExclamationMark;
			case '<':
				if (EatChar('<')) {
					if (EatChar('=')) return CiToken.ShiftLeftAssign;
					return CiToken.ShiftLeft;
				}
				if (EatChar('=')) return CiToken.LessOrEqual;
				return CiToken.Less;
			case '>':
				if (this.ParsingTypeArg) return CiToken.RightAngle;
				if (EatChar('>')) {
					if (EatChar('=')) return CiToken.ShiftRightAssign;
					return CiToken.ShiftRight;
				}
				if (EatChar('=')) return CiToken.GreaterOrEqual;
				return CiToken.Greater;
			case '\'':
				if (PeekChar() == '\'') {
					ReportError("Empty character literal");
					this.LongValue = 0;
				}
				else
					this.LongValue = ReadCharLiteral();
				if (!EatChar('\''))
					ReportError("Unterminated character literal");
				return CiToken.LiteralChar;
			case '"':
				return ReadString(false);
			case '$':
				if (EatChar('"'))
					return ReadString(true);
				ReportError("Expected interpolated string");
				break;
			case '0':
				switch (PeekChar()) {
				case 'B':
				case 'b':
					ReadChar();
					return ReadIntegerLiteral(1);
				case 'O':
				case 'o':
					ReadChar();
					return ReadIntegerLiteral(3);
				case 'X':
				case 'x':
					ReadChar();
					return ReadIntegerLiteral(4);
				default:
					return ReadNumberLiteral(0);
				}
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				return ReadNumberLiteral(c - '0');
			default:
				ReadId(c);
				switch (this.StringValue) {
				case "": continue; // invalid character
				case "abstract": return CiToken.Abstract;
				case "assert": return CiToken.Assert;
				case "break": return CiToken.Break;
				case "case": return CiToken.Case;
				case "class": return CiToken.Class;
				case "const": return CiToken.Const;
				case "continue": return CiToken.Continue;
				case "default": return CiToken.Default;
				case "do": return CiToken.Do;
				case "else": return CiToken.Else;
				case "enum": return CiToken.Enum;
				case "false": return CiToken.False;
				case "for": return CiToken.For;
				case "foreach": return CiToken.Foreach;
				case "if": return CiToken.If;
				case "in": return CiToken.In;
				case "internal": return CiToken.Internal;
				case "is": return CiToken.Is;
				case "lock": return CiToken.Lock_;
				case "native": return CiToken.Native;
				case "new": return CiToken.New;
				case "null": return CiToken.Null;
				case "override": return CiToken.Override;
				case "protected": return CiToken.Protected;
				case "public": return CiToken.Public;
				case "resource": return CiToken.Resource;
				case "return": return CiToken.Return;
				case "sealed": return CiToken.Sealed;
				case "static": return CiToken.Static;
				case "switch": return CiToken.Switch;
				case "throw": return CiToken.Throw;
				case "throws": return CiToken.Throws;
				case "true": return CiToken.True;
				case "virtual": return CiToken.Virtual;
				case "void": return CiToken.Void;
				case "when": return CiToken.When;
				case "while": return CiToken.While;
				default: return CiToken.Id;
				}
			}
		}
	}

	void NextPreToken!()
	{
		this.CurrentToken = ReadPreToken();
	}

	protected bool See(CiToken token) => this.CurrentToken == token;

	public static string TokenToString(CiToken token)
	{
		switch (token) {
		case CiToken.EndOfFile: return "end-of-file";
		case CiToken.Id: return "identifier";
		case CiToken.LiteralLong: return "integer constant";
		case CiToken.LiteralDouble: return "floating-point constant";
		case CiToken.LiteralChar: return "character constant";
		case CiToken.LiteralString: return "string constant";
		case CiToken.InterpolatedString: return "interpolated string";
		case CiToken.Semicolon: return "';'";
		case CiToken.Dot: return "'.'";
		case CiToken.Comma: return "','";
		case CiToken.LeftParenthesis: return "'('";
		case CiToken.RightParenthesis: return "')'";
		case CiToken.LeftBracket: return "'['";
		case CiToken.RightBracket: return "']'";
		case CiToken.LeftBrace: return "'{'";
		case CiToken.RightBrace: return "'}'";
		case CiToken.Plus: return "'+'";
		case CiToken.Minus: return "'-'";
		case CiToken.Asterisk: return "'*'";
		case CiToken.Slash: return "'/'";
		case CiToken.Mod: return "'%'";
		case CiToken.And: return "'&'";
		case CiToken.Or: return "'|'";
		case CiToken.Xor: return "'^'";
		case CiToken.Tilde: return "'~'";
		case CiToken.ShiftLeft: return "'<<'";
		case CiToken.ShiftRight: return "'>>'";
		case CiToken.Equal: return "'=='";
		case CiToken.NotEqual: return "'!='";
		case CiToken.Less: return "'<'";
		case CiToken.LessOrEqual: return "'<='";
		case CiToken.Greater: return "'>'";
		case CiToken.GreaterOrEqual: return "'>='";
		case CiToken.RightAngle: return "'>'";
		case CiToken.CondAnd: return "'&&'";
		case CiToken.CondOr: return "'||'";
		case CiToken.ExclamationMark: return "'!'";
		case CiToken.Hash: return "'#'";
		case CiToken.Assign: return "'='";
		case CiToken.AddAssign: return "'+='";
		case CiToken.SubAssign: return "'-='";
		case CiToken.MulAssign: return "'*='";
		case CiToken.DivAssign: return "'/='";
		case CiToken.ModAssign: return "'%='";
		case CiToken.AndAssign: return "'&='";
		case CiToken.OrAssign: return "'|='";
		case CiToken.XorAssign: return "'^='";
		case CiToken.ShiftLeftAssign: return "'<<='";
		case CiToken.ShiftRightAssign: return "'>>='";
		case CiToken.Increment: return "'++'";
		case CiToken.Decrement: return "'--'";
		case CiToken.QuestionMark: return "'?'";
		case CiToken.Colon: return "':'";
		case CiToken.FatArrow: return "'=>'";
		case CiToken.Range: return "'..'";
		case CiToken.DocRegular:
		case CiToken.DocBullet:
		case CiToken.DocBlank:
			return "'///'";
		case CiToken.Abstract: return "'abstract'";
		case CiToken.Assert: return "'assert'";
		case CiToken.Break: return "'break'";
		case CiToken.Case: return "'case'";
		case CiToken.Class: return "'class'";
		case CiToken.Const: return "'const'";
		case CiToken.Continue: return "'continue'";
		case CiToken.Default: return "'default'";
		case CiToken.Do: return "'do'";
		case CiToken.Else: return "'else'";
		case CiToken.Enum: return "'enum'";
		case CiToken.False: return "'false'";
		case CiToken.For: return "'for'";
		case CiToken.Foreach: return "'foreach'";
		case CiToken.If: return "'if'";
		case CiToken.In: return "'in'";
		case CiToken.Internal: return "'internal'";
		case CiToken.Is: return "'is'";
		case CiToken.Lock_: return "'lock'";
		case CiToken.Native: return "'native'";
		case CiToken.New: return "'new'";
		case CiToken.Null: return "'null'";
		case CiToken.Override: return "'override'";
		case CiToken.Protected: return "'protected'";
		case CiToken.Public: return "'public'";
		case CiToken.Resource: return "'resource'";
		case CiToken.Return: return "'return'";
		case CiToken.Sealed: return "'sealed'";
		case CiToken.Static: return "'static'";
		case CiToken.Switch: return "'switch'";
		case CiToken.Throw: return "'throw'";
		case CiToken.Throws: return "'throws'";
		case CiToken.True: return "'true'";
		case CiToken.Virtual: return "'virtual'";
		case CiToken.Void: return "'void'";
		case CiToken.When: return "'when'";
		case CiToken.While: return "'while'";
		case CiToken.EndOfLine: return "end-of-line";
		case CiToken.PreIf: return "'#if'";
		case CiToken.PreElIf: return "'#elif'";
		case CiToken.PreElse: return "'#else'";
		case CiToken.PreEndIf: return "'#endif'";
		default: assert false;
		}
	}

	protected bool Check(CiToken expected)
	{
		if (See(expected))
			return true;
		ReportError($"Expected {TokenToString(expected)}, got {TokenToString(this.CurrentToken)}");
		return false;
	}

	bool EatPre!(CiToken token)
	{
		if (See(token)) {
			NextPreToken();
			return true;
		}
		return false;
	}

	bool ParsePrePrimary!()
	{
		if (EatPre(CiToken.ExclamationMark))
			return !ParsePrePrimary();
		if (EatPre(CiToken.LeftParenthesis)) {
			bool result = ParsePreOr();
			Check(CiToken.RightParenthesis);
			NextPreToken();
			return result;
		}
		if (See(CiToken.Id)) {
			bool result = this.PreSymbols.Contains(this.StringValue);
			NextPreToken();
			return result;
		}
		if (EatPre(CiToken.False))
			return false;
		if (EatPre(CiToken.True))
			return true;
		ReportError("Invalid preprocessor expression");
		return false;
	}

	bool ParsePreEquality!()
	{
		bool result = ParsePrePrimary();
		for (;;) {
			if (EatPre(CiToken.Equal))
				result = result == ParsePrePrimary();
			else if (EatPre(CiToken.NotEqual))
				result ^= ParsePrePrimary();
			else
				return result;
		}
	}

	bool ParsePreAnd!()
	{
		bool result = ParsePreEquality();
		while (EatPre(CiToken.CondAnd))
			result &= ParsePreEquality();
		return result;
	}

	bool ParsePreOr!()
	{
		bool result = ParsePreAnd();
		while (EatPre(CiToken.CondOr))
			result |= ParsePreAnd();
		return result;
	}

	bool ParsePreExpr!()
	{
		this.LineMode = true;
		NextPreToken();
		bool result = ParsePreOr();
		Check(CiToken.EndOfLine);
		this.LineMode = false;
		return result;
	}

	void ExpectEndOfLine!(string directive)
	{
		this.LineMode = true;
		CiToken token = ReadPreToken();
		if (token != CiToken.EndOfLine && token != CiToken.EndOfFile)
			ReportError($"Unexpected characters after '{directive}'");
		this.LineMode = false;
	}

	bool PopPreElse!(string directive)
	{
		if (this.PreElseStack.Count == 0) {
			ReportError($"'{directive}' with no matching '#if'");
			return false;
		}
		if (this.PreElseStack.Pop() && directive != "#endif")
			ReportError($"'{directive}' after '#else'");
		return true;
	}

	void SkipUnmet!(CiPreState state)
	{
		this.EnableDocComments = false;
		for (;;) {
			// state == CiPreState.NotYet: we are in a conditional that wasn't met yet
			// else: we are in a conditional that was met before
			switch (ReadPreToken()) {
			case CiToken.EndOfFile:
				ReportError("Expected '#endif', got end-of-file");
				return;
			case CiToken.PreIf:
				ParsePreExpr();
				SkipUnmet(CiPreState.Already);
				break;
			case CiToken.PreElIf:
				if (state == CiPreState.AlreadyElse)
					ReportError("'#elif' after '#else'");
				if (ParsePreExpr() && state == CiPreState.NotYet) {
					this.PreElseStack.Push(false);
					return;
				}
				break;
			case CiToken.PreElse:
				if (state == CiPreState.AlreadyElse)
					ReportError("'#else' after '#else'");
				ExpectEndOfLine("#else");
				if (state == CiPreState.NotYet) {
					this.PreElseStack.Push(true);
					return;
				}
				state = CiPreState.AlreadyElse;
				break;
			case CiToken.PreEndIf:
				ExpectEndOfLine("#endif");
				return;
			default:
				break;
			}
		}
	}

	CiToken ReadToken!()
	{
		for (;;) {
			// we are in no conditionals or in all met
			this.EnableDocComments = true;
			CiToken token = ReadPreToken();
			bool matched;
			switch (token) {
			case CiToken.EndOfFile:
				if (this.PreElseStack.Count != 0)
					ReportError("Expected '#endif', got end-of-file");
				return CiToken.EndOfFile;
			case CiToken.PreIf:
				if (ParsePreExpr())
					this.PreElseStack.Push(false);
				else
					SkipUnmet(CiPreState.NotYet);
				break;
			case CiToken.PreElIf:
				matched = PopPreElse("#elif");
				ParsePreExpr();
				if (matched)
					SkipUnmet(CiPreState.Already);
				break;
			case CiToken.PreElse:
				matched = PopPreElse("#else");
				ExpectEndOfLine("#else");
				if (matched)
					SkipUnmet(CiPreState.AlreadyElse);
				break;
			case CiToken.PreEndIf:
				PopPreElse("#endif");
				ExpectEndOfLine("#endif");
				break;
			default:
				return token;
			}
		}
	}

	protected CiToken NextToken!()
	{
		CiToken token = this.CurrentToken;
		this.CurrentToken = ReadToken();
		return token;
	}

	protected bool Eat!(CiToken token)
	{
		if (See(token)) {
			NextToken();
			return true;
		}
		return false;
	}

	protected bool Expect!(CiToken expected)
	{
		bool found = Check(expected);
		NextToken();
		return found;
	}

	protected void ExpectOrSkip!(CiToken expected)
	{
		if (Check(expected))
			NextToken();
		else {
			do
				NextToken();
			while (!See(CiToken.EndOfFile) && !Eat(expected));
		}
	}
}
